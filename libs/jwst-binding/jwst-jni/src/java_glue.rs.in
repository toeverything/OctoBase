//Automatically generated by rifgen
use crate::*;

use jni_sys::*;
foreign_typemap!(
    ($p:r_type) Vec<u8> => jbyteArray {
        let slice = &($p)[..];
        let slice = unsafe { std::mem::transmute::<&[u8], &[i8]>(slice) };
        let raw = JavaByteArray::from_slice_to_raw(slice, env);
        $out = raw;
    };
    ($p:f_type) => "jbyteArray";
);

foreign_typemap!(
    ($p:r_type) Vec<u8> => jbyteArray {
        let slice = &($p)[..];
        let slice = unsafe { std::mem::transmute::<&[u8], &[i8]>(slice) };
        let raw = JavaByteArray::from_slice_to_raw(slice, env);
        $out = raw;
    };
    ($p:f_type) => "jbyteArray";
    ($p:r_type) &'a [u8] <= jbyteArray {
        let arr = JavaByteArray::new(env, $p);
        let slice = arr.to_slice();
        let slice = unsafe { std::mem::transmute::<&[i8], &[u8]>(slice) };
        $out = slice;
    };
    ($p:f_type) <= "jbyteArray";
);
foreign_class!(
    class JwstStorage {
        self_type JwstStorage;
        constructor JwstStorage::new(path: String) -> JwstStorage;
        constructor JwstStorage::new_with_log_level(path: String, level: String) -> JwstStorage;
        fn JwstStorage::error(&self) -> Option<String>; alias error;
        fn JwstStorage::is_offline(&self) -> bool;
        fn JwstStorage::is_connected(&self) -> bool;
        fn JwstStorage::is_finished(&self) -> bool;
        fn JwstStorage::is_error(&self) -> bool;
        fn JwstStorage::get_sync_state(&self) -> String;
        fn JwstStorage::init(&mut self, workspace_id: String, data: &[u8]) -> bool; alias init;
        fn JwstStorage::export(&mut self, workspace_id: String) -> Vec<u8>; alias export;
        fn JwstStorage::connect(&mut self, workspace_id: String, remote: String) -> Option<Workspace>; alias connect;
        fn JwstStorage::get_last_synced(&self) ->Vec<i64>;
    }
);

pub type VecOfStrings = Vec<String>;
foreign_class!(
    class VecOfStrings {
        self_type VecOfStrings;

        constructor default() -> VecOfStrings {
            Vec::<String>::default()
        }

        fn at(&self, i: usize) -> &str {
            this[i].as_str()
        }

        fn len(&self) -> usize {
            this.len()
        }

        fn push(&mut self, s: String) {
            this.push(s);
        }

        fn insert(&mut self, i: usize, s: String) {
            this.insert(i, s);
        }

        fn clear(&mut self) {
            this.clear();
        }

        fn remove(&mut self, i: usize) {
            this.remove(i);
        }

        fn remove_item(&mut self, s: String) {
            this.retain(|x| x != &s);
        }
    }
);

foreign_class!(
	class Block {
		self_type Block;
		constructor Block::new(ws : & Workspace , block_id : String , flavour : String , operator : u64)->Block;
		fn Block::set_bool(& self , key : String , value : bool); alias setBool;
		fn Block::set_string(& self , key : String , value : String); alias setString;
		fn Block::set_float(& self , key : String , value : f64); alias setFloat;
		fn Block::set_integer(& self , key : String , value : i64); alias setInteger;
		fn Block::set_null(& self , key : String); alias setNull;
		fn Block::is_bool(& self , key : String)->bool; alias isBool;
		fn Block::is_string(& self , key : String)->bool; alias isString;
		fn Block::is_float(& self , key : String)->bool; alias isFloat;
		fn Block::is_integer(& self , key : String)->bool; alias isInteger;
		fn Block::get_bool(& self , key : String)->Option<i64>; alias getBool;
		fn Block::get_string(& self , key : String)->Option<String>; alias getString;
		fn Block::get_float(& self , key : String)->Option<f64>; alias getFloat;
		fn Block::get_integer(& self , key : String)->Option<i64>; alias getInteger;
		fn Block::id(& self)->String; alias id;
		fn Block::flavour(& self)->String; alias flavour;
		fn Block::created(& self)->u64; alias created;
		fn Block::updated(& self)->u64; alias updated;
		fn Block::parent(& self)->Option<String>; alias parent;
		fn Block::children(& self)->Vec<String>; alias children;
		fn Block::push_children(& self , block : & Block); alias pushChildren;
		fn Block::insert_children_at(& self , block : & Block , pos : u64); alias insertChildrenAt;
		fn Block::insert_children_before(& self , block : & Block , reference : & str); alias insertChildrenBefore;
		fn Block::insert_children_after(& self , block : & Block , reference : & str); alias insertChildrenAfter;
		fn Block::remove_children(& self , block : & Block); alias removeChildren;
		fn Block::exists_children(& self , block_id : & str)->i32; alias existsChildren;
	}
);
foreign_class!(
	class Workspace {
		self_type Workspace;
		constructor Workspace::new(_id : String)->Workspace;
		fn Workspace::id(& self)->String; alias id;
		fn Workspace::client_id(& self)->u64; alias clientId;
		fn Workspace::create(& mut self , block_id : String , flavour : String)->Block; alias create;
		fn Workspace::get(& mut self , block_id : String)->Option<Block>; alias get;
		fn Workspace::get_blocks_by_flavour(& self , flavour : & str)->Vec<Block>; alias getBlocksByFlavour;
		fn Workspace::exists(& self , block_id : & str)->bool; alias exists;
		fn Workspace::remove(& mut self , block_id : String)->bool; alias remove;
		fn Workspace::search(& self , _query : String)->String; alias search;
		fn Workspace::get_search_index(& self)->Vec<String>; alias getSearchIndex;
		fn Workspace::set_search_index(& self , _fields : VecOfStrings)->bool; alias setSearchIndex;
	}
);
